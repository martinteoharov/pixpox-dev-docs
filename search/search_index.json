{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pixpox-engine","title":"PixPox Engine","text":"<p>PixPox is a 2D Game Engine built around the concept of simulating most pixels on screen using simple cellular automaton rules! </p> <p>This obsidian vault is to be a research database. It will document the design patterns, data structures, algorithms and various optimizations used throughout the project.</p>"},{"location":"#book-index","title":"Book Index","text":"<ul> <li>I. Vision</li> <li>II. World</li> <li>III. Storage</li> <li>IV. Cellular Automaton</li> <li>V. Renderer</li> </ul>"},{"location":"I.%20Vision/","title":"I. Vision","text":"<p>PixPox is inspired by the rogue-like Noita.</p> <p>The aim is to provide game developers with the essentials tools for creating games similar to the aforementioned.</p> <p>The Cellular Automaton computation is optimised to run on the CPU making use of multi-threading for parallelisation. No GPU acceleration has been or is planned to be implemented in the context of CA. At most MSID will be considered.</p>"},{"location":"I.%20Vision/#overview","title":"Overview","text":"<p>PixPox is very tiny and is comprised of: - A rendering engine (based on WGPU). - An Entity Component System (ECS). - A Cellular Automaton engine.</p> <p>For the time being the rendering is outsourced to the project Pixels. </p>"},{"location":"I.%20Vision/#why-rust","title":"Why Rust?","text":"<p>In part because I wanted to learn the language, but also: - Achieving good performance in PixPox means implementing a ton of parallelisation. Rust is really good when it comes to safe, multithreaded applications. - Gives me fine control of all the small bits and pieces that will come into this project. - I wanted to make a reliable and structured system, hence a systems programming language. - Type safety, performance, cross-compilation and all the other good stuff.. (and also WASM!)</p>"},{"location":"I.%20Vision/#main-concepts","title":"Main concepts","text":""},{"location":"I.%20Vision/#pixelmaps-and-object-representation","title":"PixelMaps and object representation","text":"<p>The primary data structure for representing the game world in PixPox is the <code>PixelMap</code>. All components that intend to interact with the game world must implement a <code>PixelMap</code>.</p> <p>The use of the <code>PixelMap</code> data structure greatly simplifies collision detection and physics calculations. For instance, to detect collisions between two <code>PixelMaps</code>, one could simply perform a XOR operation on the two objects to obtain the overlapping region. Based on this information, the physics system can calculate force vectors.</p> <p>The developer also has to create a <code>GlobalPixelMap</code> which is passed to the renderer. The <code>GlobalPixelMap</code> must implement a render method that accepts several arguments to allow for customisation of how the <code>GlobalPixelMap</code> renders to the window. It is recommended that the <code>GlobalPixelMap</code> maintains a global representation of the game world that other components can write to.</p>"},{"location":"I.%20Vision/#entity-component-system","title":"Entity Component System","text":"<p>The Entity Component System consists of three main parts: entities, components, and systems. An entity is an object in the game world that has a unique identifier. Components are individual attributes that make up an entity, such as position or health. Finally, systems operate on one or more components, allowing entities to move, interact, or behave in some specified way.</p> <p>The primary benefit of using an Entity Component System in game development is that it allows for greater flexibility and reusability of code. By separating entities into their component parts, game developers can create more modular and extensible code that can be more easily modified and reused across different types of games.</p> <p>Additionally, the separation of components in an Entity Component System also simplifies parallelisation, which can lead to improved performance. Since each system is responsible for processing one or more components, they can be run independently in parallel. This allows for improved CPU utilisation and overall system performance.</p> <p>PixPox's implementation of the Entity Component System pattern is unique in that every component implements its own system. This differs from more common implementations of ECS, where systems are typically implemented independently of the components. At present, there is no way to create a system that is not attached to a component in PixPox. Despite this difference, the core benefits of the Entity Component System pattern, such as improved abstraction and parallelisation, still apply to PixPox.</p> <p>There are additional aspects related to the ECS implementation that merit discussion, such as queries, storage systems, mutexes, and parallelization. However, these will be detailed on a separate page.</p>"},{"location":"I.%20Vision/#rendering","title":"Rendering","text":"<p>The renderer in PixPox is simply a 2D texture that is passed to the GPU. Any changes to the game world are written to the texture as needed. Currently, PixPox uses an open-source project called \"pixels\" to simplify the rendering process. However, in future development stages, a renderer will be implemented from the ground up to better fit the specific needs of PixPox.</p>"},{"location":"I.%20Vision/#physics","title":"Physics","text":"<p>PixPox features two virtual worlds when it comes to physics: one for cellular automaton (CA) interactions and one for Newtonian physics. A component can exist in either the realm of CA or Newtonian physics, although both systems are capable of interacting with each other, but on a more primitive level.</p> <p>In PixPox, the behaviour of certain objects, such as the player, is determined by Newtonian physics, while other objects, such as a pool of water, use cellular automata to simulate behavior. The interaction between objects in different realms is facilitated by a simple collider that prevents the two objects from occupying the same space but allows them to be positioned side by side for example.</p>"},{"location":"II.%20World/","title":"II. World","text":"<p>For a summary of the concept, read I. Vision#Entity Component System.</p> <p>The Entity Component System (ECS) is a powerful design pattern that facilitates the representation of a game world and its myriad of objects and algorithms, such as players, lights, terrain, physics, and more. An ECS comprises of entities, which are composed of components and lastly systems which operate on said entities.</p> <p>By separating entities into their individual components, developers can create a flexible and high-performing logic that's perfect for complex game engines. This approach enables the creation of modular and extensible code that's easily modified and reused across various types of games.</p> <p>The separation of components in an ECS also simplifies parallelization, which can result in improved performance. Because each system is responsible for processing one or more components, they can be run independently in parallel. This leads to increased CPU utilization and enhanced overall system performance.</p>"},{"location":"II.%20World/#how-it-is-built","title":"How it is built","text":""},{"location":"II.%20World/#entities","title":"Entities","text":"<p>Entities are very simple. They are basically just a number - their ID. The EntityManager struct also includes methods for creating and deleting entities.</p> <p>Fields:</p> <ul> <li> <p>id</p> <p>Each entity in the game world possesses a unique identifier. These IDs start from 0 and increment by 1 for every new entity that's created. At present, the ID value doesn't decrement on entity removal, as it's deemed unnecessary. In the future, a better implementation will utilize a queue data structure to retrieve the smallest possible ID for a new entity.</p> </li> </ul>"},{"location":"II.%20World/#components","title":"Components","text":"<p>Components are stored in the world in a <code>Vec&lt;Box&lt;dyn ComponentVec&gt;&gt;</code> structure, which allows for efficient memory packing. This data structure is essentially a vector of heap-allocated vectors with additional custom logic attached to the inner vector.</p> <p>// TODO: Clarify this &amp; Make sure it makes complete sense One advantage of this approach is that it enables us to optimize memory usage by packing data tightly into the smallest amount of memory required. This is achieved by organizing the components in memory so that there are no gaps between them, which reduces the amount of unused space in memory. In addition, the use of heap-allocated vectors allows for easy dynamic allocation and modification of components as needed during runtime.</p> <p>As a developer using PixPox, you have the freedom to create custom components. However, it is essential that these components implement specific traits so that they are accepted by the engine.</p> <pre><code>pub trait Label {\n    fn label(&amp;mut self) -&gt; &amp;'static str;\n}\n\npub trait Run {\n    fn run(&amp;mut self, storage: &amp;Storage);\n}\n\npub trait Update {\n    fn update(&amp;mut self, storage: &amp;RwLock&lt;Storage&gt;);\n}\n</code></pre> <p>The <code>Label</code> trait requires that every component has a <code>label()</code> method that prints out its type. This is useful for debugging purposes.</p> <p>The <code>Run</code> trait specifies a <code>run()</code> method that is executed for each component whenever <code>world.run()</code> is called. This function is parallelized using multi-threading and only has read access to the storage. It is designed for heavy computation, and no updates are allowed.</p> <p>The <code>Update</code> trait specifies an <code>update()</code> method, which much like <code>run()</code>  is executed on every pass of <code>world.run()</code>. It is also parallelized, but its given a <code>RwLock</code> instead of an immutable reference. This method is meant to update the world when a change is present, and it should not attempt to obtain a <code>.write()</code> lock on the storage when no changes are present, as doing so would adversely impact performance.</p>"},{"location":"II.%20World/#systems","title":"Systems","text":"<p>In PixPox, systems are incorporated as part of the component. Every component features two mandatory system functions: <code>Run()</code> and <code>Update()</code> as discussed in the above section. During the <code>world.run()</code> call, both functions are executed.</p> <p>Firstly, <code>Run()</code> is called on all components, with an immutable reference to the storage. It's important to note that the <code>Run()</code> method is not allowed to modify anything in the global storage. This approach is necessary because the <code>Run()</code> calls are parallelized.</p> <p>Once all <code>Run()</code> methods have been executed, <code>Update()</code> is called on each component, with a reference to a <code>RWLock</code> that's distilled into a reference of write-access to the storage. The philosophy of the <code>Update()</code> function is all about updating the global storage. As such, it shouldn't contain any computationally intensive code.</p> <p>Overall, this design ensures that all the components are processed and updated efficiently in parallel, while also safeguarding the integrity of the global storage.</p>"},{"location":"II.%20World/#rust-type-system-integration","title":"Rust Type System integration","text":"<p>There are many reasons why Rust is a fantastic language, one of which is its robust type system that introduces \"Traits\".</p> <p>In Rust, a trait is a feature that defines a set of methods that a type can implement. It is similar to interfaces in other programming languages, but with additional capabilities and flexibility.</p> <p>Traits provide a way to define shared behavior across different types. By implementing a trait, a type can guarantee that it has certain properties or capabilities, which allows it to be used in a more generic way. For example, the <code>ToString</code> trait can be implemented by any type that can be converted to a string, such as integers or custom structures.</p> <p>Additionally, traits can be used to define default behavior for types, enabling more efficient and concise code. They can also be used to enable dynamic dispatch, which is useful for building more modular and extensible code. </p> <p>In our implementation, Traits play an essential role in determining what can be a Component. For a Component to be valid, it must implement the Traits Run, Update, and Label. Additionally, a Component can optionally implement Texture, but we will discuss that later.</p> <p>In the ECS, a \"Component\" can be assigned to an entity by first creating a Component Type. Once the Component Type is defined, a variable of that type can be initialized and passed to the helper method <code>World::add_component_to_entity()</code>, which attaches the component to the entity.</p> <p>To ensure that each entity has its own copy of the Component, we require the trait Copy, as we cannot have a reference to a single component in memory for every entity. By making Components Copy-able, we can create unique instances for each entity that has the Component attached to it.</p>"},{"location":"III.%20Storage/","title":"III. Storage","text":"<p>The Storage system is designed to manage and maintain global data in the context of the entity component system. It employs a HashMap data structure to store developer-defined data of any type in buckets, and offers a comprehensive query system to facilitate the creation and retrieval of said buckets.</p> <p>The storage also uses a multi-threaded interner to efficiently store bucket labels and associate them with Spur keys, which can be used to efficiently look up data in the HashMap.</p>"},{"location":"III.%20Storage/#how-it-is-built","title":"How it is built","text":""},{"location":"III.%20Storage/#query-system","title":"Query System","text":""},{"location":"III.%20Storage/#mutability","title":"Mutability","text":""},{"location":"III.%20Storage/#philosophies","title":"Philosophies","text":""},{"location":"IV.%20Cellular%20Automaton/","title":"IV. Cellular Automaton","text":"<p>An automaton (/\u0254\u02d0\u02c8t\u0252m\u0259t\u0259n/; plural: automata or automatons) is a relatively self-operating machine, or control mechanism designed to automatically follow a sequence of operations, or respond to predetermined instructions.</p> <p>A cellular automaton (CA) is a collection of cells arranged in a grid of specified shape, such that each cell changes state as a function of time, according to a defined set of rules driven by the states of neighboring cells. </p> <p>A CA is a collection of colored cells or atoms on a grid of a specified shape. Each cell is in one of a finite number of states. This\u00a0computational model\u00a0is both abstract and spatially and temporally discrete.</p> <p>Computational\u00a0means the model can compute functions and solve\u00a0algorithmic\u00a0problems.\u00a0Abstract\u00a0refers to the fact that a CA can be specified in purely mathematical terms. A CA is discrete in both space and time, which means that in each time unit, the cells that constitute the CA represent one of a finite set of states. Additionally, the cells in a grid evolve in parallel at discrete time steps by considering the states of neighboring cells.</p> <p>As a result, the evolution of the CA through several discrete time steps occurs based on a set of rules founded on the states of neighboring cells. These rules can be iteratively applied for as many time steps as required.</p> <p>Typical characteristics of a CA are the following:</p> <ul> <li>The cells in a CA reside on a grid which has a specified shape (square, triangle, hexagon, etc.) and exist in a finite number of dimensions.</li> <li>Each cell on the grid has a state. While there are numerous finite possibilities of the state, the simplest state form is usually ON or OFF (or TRUE/FALSE or 1/0).</li> <li>The cells adjacent to one cell constitute its neighborhood. Cells in a neighborhood affect each other, and each cell on the CA grid has a neighborhood.</li> </ul>"},{"location":"Sources/","title":"Sources","text":"<p>This file holds links to external sources. The same indexing is used throughout the whole vault.</p>"},{"location":"Sources/#game-design-patterns","title":"Game Design Patterns","text":"<p>https://gameprogrammingpatterns.com/contents.html</p>"},{"location":"Sources/#noita-research","title":"Noita Research","text":"<p>https://www.reddit.com/r/gamedev/comments/d93op6/comment/f1eexqp/ https://www.gdcvault.com/play/1025695/Exploring-the-Tech-and-Design https://www.reddit.com/r/Games/comments/d7cqjz/comment/f0z8hu8/?utm_source=share&amp;utm_medium=web2x</p>"},{"location":"TODO/","title":"TODO","text":""},{"location":"TODO/#game-engine","title":"Game Engine","text":"<ul> <li> Architecture</li> <li> Features<ul> <li> State serialisation </li> <li> Level builder</li> <li> Newtonian physics</li> <li> Texture system<ul> <li> Components must implement texture trait</li> <li> Components can have textures attached to them that can be rendered</li> </ul> </li> </ul> </li> <li> Fixes<ul> <li> ...</li> </ul> </li> </ul>"}]}